{"name":"Fluorine","tagline":"flow based programing abstraction","body":"Fluorine\r\n========\r\n\r\nFluorine - Flow based programing abstraction.\r\n\r\nFluorine can simply be though of as an abstraction or a DSL.\r\nIt is a structure of code in which you can manage complex asynchronous\r\ncode with ease.\r\n\r\nProbably one of the most important features of Fluorine is its\r\nnon-intrusive philosophy, since it separates code from structure.\r\n\r\nThis \"structure\" is though of as a flow within a graph, where each node\r\nin the graph is a function that runs some synchronous or asynchronous\r\ncode.\r\n\r\nNow, even though this sounds very simple, it is quite powerful, because\r\nyou can code the \"flow\" which is the order in which functions will run,\r\nand then go ahead and code the behavior that will run within each node\r\nseparately.\r\n\r\nThis simple fact, allows for clean, maintainable, simpler and atomic code.\r\nRemoving callback-hells, nesting, smells, complexity.\r\n\r\nYou may not realize until you get there, but refactoring a flow consists\r\nof re-arranging the order of the nodes, while on the other hand you'll\r\nprobaly produce a lot of bugs while trying to refactor all the mixed,\r\nnested complexity that lies in front of you. That is.. if you return\r\nalive from mordor.\r\n\r\nNow, within the Fluorine world, the program is a graph, the execution of\r\nthe program is called a flow and each node is called a step.\r\n\r\nLet us Orchestrate asynchronous and synchronous code!\r\n\r\nUsage\r\n=====\r\n\r\nBasically you instantiate a flow.\r\nThen you add a step to the flow.\r\nAny step can have other steps as dependancies.\r\n\r\nWhen the program runs, it will run each step only if all of its\r\ndependancies have been met.\r\n\r\nDependencies/Requirements\r\n=========================\r\n\r\nRequire the libraries needed for Fluorine\r\n1. [Neon](https://github.com/azendal/neon)\r\n2. [CustomEventSupport](https://github.com/azendal/neon) (part of the\r\nNeon stdlib)\r\n3. [NodeSupport](https://github.com/azendal/neon) (part of the\r\nNeon stdlib)\r\n\r\nGeting Started\r\n==============\r\n\r\nSuppose you need to execute two asynchronous functions (someAsyncFn,\r\nanotherAsyncFn) and when both are resolved execute something with the\r\nresponse of the previous asynchronous functions.\r\n\r\n```javascript\r\nvar flow = new Flow();\r\n\r\nflow.step('bar')(function (step) {\r\n    someAsyncFn(function (someData) {\r\n        step.success(someData);\r\n    });\r\n});\r\n\r\nflow.step('baz')(function (step) {\r\n    anotherAsyncFn(function (moreData) {\r\n        step.success(moreData);\r\n    });\r\n});\r\n\r\nflow.step('foo').dependsOn('bar', 'baz')(function (step) {\r\n    // step.data.bar has someData as passed by the bar step\r\n    // step.data.baz has moreData as passed by the baz step\r\n    // Execute something else and then finish\r\n    step.success();\r\n});\r\n```\r\n\r\nExamples\r\n========\r\n\r\nNo more coupling async methods with unecessary nesting, let suppose\r\nyou have fn1, fn2, fn3 and fn4 which are function that are asynchronous,\r\nand you want to call them in sequence after each other\r\n\r\nUsing nested callbacks\r\n```javascript\r\nfn1(function () {\r\n    // execute some code\r\n    fn2(function () {\r\n        // more code\r\n        fn3(function () {\r\n            // ...\r\n            fn4(function () {\r\n                // finalize\r\n            });\r\n        });\r\n    });\r\n});\r\n```\r\n\r\nUsing Fluorine\r\n```javascript\r\nvar f = new Flow();\r\n\r\nf.step('1')(function (step) {\r\n    // execute some code\r\n    fn1(step.success);\r\n});\r\n\r\nf.step('2').dependsOn('1')(function (step) {\r\n    // more code\r\n    fn2(step.success);\r\n});\r\n\r\nflow.step('3').dependsOn('2')(function (step) {\r\n    // ...\r\n    fn3(step.success);\r\n});\r\n\r\nflow.step('4').dependsOn('3')(function (step) {\r\n    // finalize\r\n    fn4(step.success);\r\n});\r\n```\r\n\r\nLet run fn1, fn2 and fn3 and only execute fn4 after the previous funcitons finish\r\n```javascript\r\nvar f = new Flow();\r\n\r\nf.step('1')(function (step) {\r\n    fn1(step.success);\r\n});\r\n\r\nf.step('2')(function (step) {\r\n    fn2(step.success);\r\n});\r\n\r\nf.step('3')(function (step) {\r\n    fn3(step.success);\r\n});\r\n\r\nf.step('4').dependsOn('1', '2', '3')(function (step) {\r\n    fn4(step.success);\r\n});\r\n```\r\n\r\nExecute fn1 and fn2 then when both are ready execute fn3 and then fn4\r\n```javascript\r\nvar f = new Flow();\r\n\r\nf.step('1')(function (step) {\r\n    fn1(step.success);\r\n});\r\n\r\nf.step('2')(function (step) {\r\n    fn2(step.success);\r\n});\r\n\r\nf.step('3').dependsOn('1', '2')(function (step) {\r\n    fn3(step.success);\r\n});\r\n\r\nf.step('4').dependsOn('3')(function (step) {\r\n    fn4(step.success);\r\n});\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}